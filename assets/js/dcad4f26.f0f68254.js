"use strict";(globalThis.webpackChunkdocdevtron=globalThis.webpackChunkdocdevtron||[]).push([[93977],{28453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>r});var n=s(96540);const o={},i=n.createContext(o);function l(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),n.createElement(i.Provider,{value:t},e.children)}},54255:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"user-guide/creating-application/base-config/deployment-template-types/job-and-cronjob","title":"Job and CronJob","description":"This chart deploys Job & CronJob. A Job is a controller object that represents a finite task and CronJob is used to schedule the creation of Jobs.","source":"@site/docs/user-guide/creating-application/base-config/deployment-template-types/job-and-cronjob.md","sourceDirName":"user-guide/creating-application/base-config/deployment-template-types","slug":"/user-guide/creating-application/base-config/deployment-template-types/job-and-cronjob","permalink":"/docs/user-guide/creating-application/base-config/deployment-template-types/job-and-cronjob","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Rollout Deployment","permalink":"/docs/user-guide/creating-application/base-config/deployment-template-types/rollout-deployment"},"next":{"title":"StatefulSet","permalink":"/docs/user-guide/creating-application/base-config/deployment-template-types/statefulset"}}');var o=s(74848),i=s(28453);const l={},r="Job and CronJob",a={},d=[{value:"1. Job",id:"1-job",level:2},{value:"<strong>Example:</strong>",id:"example",level:2},{value:"2. CronJob",id:"2-cronjob",level:2},{value:"<strong>Example:</strong>",id:"example-1",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"job-and-cronjob",children:"Job and CronJob"})}),"\n",(0,o.jsx)(t.p,{children:"This chart deploys Job & CronJob. A Job is a controller object that represents a finite task and CronJob is used to schedule the creation of Jobs."}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#1-job",children:"Job"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"#2-cronjob",children:"CronJob"})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.img,{src:"https://devtron-public-asset.s3.us-east-2.amazonaws.com/images/devtron-v2/app-management/devtron-apps/select-job-cronjob.jpg",alt:""}),"\n",(0,o.jsx)("center",{children:"Figure 1: Choosing 'Job & CronJob' Chart"})]}),"\n",(0,o.jsx)(t.h2,{id:"1-job",children:"1. Job"}),"\n",(0,o.jsx)(t.p,{children:"A Job creates one or more Pods and will continue to retry execution of the Pods until a specified number of them successfully terminate. As pods successfully complete, the Job tracks the successful completions. When a specified number of successful completions is reached, the task (ie, Job) is complete. Deleting a Job will clean up the Pods it created. Suspeding a Job will delete its active Pods until the Job is resumed again."}),"\n",(0,o.jsx)(t.h2,{id:"example",children:(0,o.jsx)(t.strong,{children:"Example:"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-yaml",children:"kind: Job\njobConfigs:\n    activeDeadlineSeconds: 120\n    backoffLimit: 6\n    completions: 1\n    parallelism: 1\n    suspend: false\n    ttlSecondsAfterFinished: 100\n"})}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Key"}),(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"activeDeadlineSeconds"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"Another way to terminate a Job is by setting an active deadline. Do this by setting the activeDeadlineSeconds field of the Job to a number of seconds. The activeDeadlineSeconds applies to the duration of the job, no matter how many Pods are created. Once a Job reaches activeDeadlineSeconds, all of its running Pods are terminated and the Job status will become type: Failed with reason: DeadlineExceeded."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"backoffLimit"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"There are situations where you want to fail a Job after some amount of retries due to a logical error in configuration etc. To do so, set backoffLimit to specify the number of retries before considering a Job as failed. The back-off limit is set by default to 6. Failed Pods associated with the Job are recreated by the Job controller with an exponential back-off delay (10s, 20s, 40s ...) capped at six minutes. The back-off count is reset when a Job's Pod is deleted or successful without any other Pods for the Job failing around that time."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"completions"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"Jobs with fixed completion count - that is , jobs that have non null completions - can have a completion mode that is specified in completionMode."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"parallelism"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The requested parallelism can be set to any non-negative value. If it is unspecified, it defaults to 1. If it is specified as 0, then the Job is effectively paused until it is increased."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"suspend"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The suspend field is also optional. If it is set to true, all subsequent executions are suspended. This setting does not apply to already started executions. Defaults to false."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"ttlSecondsAfterFinished"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The TTL controller only supports Jobs for now. A cluster operator can use this feature to clean up finished Jobs (either Complete or Failed) automatically by specifying the ttlSecondsAfterFinished field of a Job, as in this example. The TTL controller will assume that a resource is eligible to be cleaned up TTL seconds after the resource has finished, in other words, when the TTL has expired. When the TTL controller cleans up a resource, it will delete it cascadingly, that is to say it will delete its dependent objects together with it. Note that when the resource is deleted, its lifecycle guarantees, such as finalizers, will be honored."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"kind"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"As with all other Kubernetes config, a Job and cronjob needs apiVersion, kind.cronjob and job also needs a section fields which is optional . these fields specify to deploy which job (conjob or job) should be kept. by default, they are set job."})]})]})]}),"\n",(0,o.jsx)(t.h2,{id:"2-cronjob",children:"2. CronJob"}),"\n",(0,o.jsx)(t.p,{children:"A CronJob creates jobs on a repeating schedule. One Cronjob object is like one line of a crontab (cron table) file. It runs a job periodically on a given schedule, written in Cron format.\nCronJobs are meant for performing regular scheduled actions such as backups, report generation, and so on. Each task must be configured to recur indefinitely (as an example: once a day / week / month). You can schedule the time within that interval when the job should start."}),"\n",(0,o.jsx)(t.h2,{id:"example-1",children:(0,o.jsx)(t.strong,{children:"Example:"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-yaml",children:"kind: CronJob\ncronjobConfigs:\n    concurrencyPolicy: Allow\n    failedJobsHistoryLimit: 1\n    restartPolicy: OnFailure\n    schedule: 32 8 * * *\n    startingDeadlineSeconds: 100\n    successfulJobsHistoryLimit: 3\n    suspend: false\n"})}),"\n",(0,o.jsxs)(t.table,{children:[(0,o.jsx)(t.thead,{children:(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Key"}),(0,o.jsx)(t.th,{style:{textAlign:"left"},children:"Descriptions"})]})}),(0,o.jsxs)(t.tbody,{children:[(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"concurrencyPolicy"})}),(0,o.jsxs)(t.td,{style:{textAlign:"left"},children:["A CronJob is counted as missed if it has failed to be created at its scheduled time. For example, If concurrencyPolicy is set to Forbid and a CronJob was attempted to be scheduled when there was a previous schedule still running, then it would count as missed,",(0,o.jsx)(t.code,{children:"Acceptable values: Allow / Forbid"}),"."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"failedJobsHistoryLimit"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The failedJobsHistoryLimit fields are optional. These fields specify how many completed and failed jobs should be kept. By default, they are set to 3 and 1 respectively. Setting a limit to 0 corresponds to keeping none of the corresponding kind of jobs after they finish."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"restartPolicy"})}),(0,o.jsxs)(t.td,{style:{textAlign:"left"},children:["The spec of a Pod has a restartPolicy field with possible values Always, OnFailure, and Never. The default value is Always.The restartPolicy applies to all containers in the Pod. restartPolicy only refers to restarts of the containers by the kubelet on the same node. After containers in a Pod exit, the kubelet restarts them with an exponential back-off delay (10s, 20s, 40s, \u2026), that is capped at five minutes. Once a container has executed for 10 minutes without any problems, the kubelet resets the restart backoff timer for that container, ",(0,o.jsx)(t.code,{children:"Acceptable values: Always / OnFailure / Never"}),"."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"schedule"})}),(0,o.jsxs)(t.td,{style:{textAlign:"left"},children:["To generate Cronjob schedule expressions, you can also use web tools like ",(0,o.jsx)(t.a,{href:"https://crontab.guru/",children:"https://crontab.guru/"}),"."]})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"startingDeadlineSeconds"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"If startingDeadlineSeconds is set to a large value or left unset (the default) and if concurrencyPolicy is set to Allow, the jobs will always run at least once."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"successfulJobsHistoryLimit"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The successfulJobsHistoryLimit fields are optional. These fields specify how many completed and failed jobs should be kept. By default, they are set to 3 and 1 respectively. Setting a limit to 0 corresponds to keeping none of the corresponding kind of jobs after they finish."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"suspend"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"The suspend field is also optional. If it is set to true, all subsequent executions are suspended. This setting does not apply to already started executions. Defaults to false."})]}),(0,o.jsxs)(t.tr,{children:[(0,o.jsx)(t.td,{style:{textAlign:"left"},children:(0,o.jsx)(t.code,{children:"kind"})}),(0,o.jsx)(t.td,{style:{textAlign:"left"},children:"As with all other Kubernetes config, a Job and cronjob needs apiVersion, kind.cronjob and job also needs a section fields which is optional . these fields specify to deploy which job (conjob or job) should be kept. by default, they are set cronjob."})]})]})]}),"\n",(0,o.jsx)(t.admonition,{title:"Note",type:"caution",children:(0,o.jsxs)(t.p,{children:["Super-admins can lock keys in Job & CronJob deployment template to prevent non-super-admins from modifying those locked keys. Refer ",(0,o.jsx)(t.a,{href:"/docs/user-guide/app-management/policies/lock-deployment-config",children:"Lock Deployment Configuration"})," to know more."]})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);